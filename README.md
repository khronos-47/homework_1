# Url-shortener application 


## Описание и технические требования

На лекции мы проследили за процессом, как разрабатывать новые крутые продуктовые фичи в нашем сервисе Такси. Давайте реализуем что-то похожее на небольшом проекте `UrlShortener`. Он всего лишь умеет укорачивать урлы и дает немного управления над созданными редиректами (можно посмотреть статистику использования и удалить ссылку).

Представьте, что нам необходимо вывести наш сервис `UrlShortener` на новый качественный уровень на рынке подобных систем. Надо завоевать долю на рынке и нарастить количество активных пользователей с X до Y %. Это стратегическая цель. Но как ее достичь?

Дальше задание разделяется на 2 пути: вы можете взять описанную ниже фичу либо придумать свою крутую. Главное — реализовать в коде и показать путь фичи от идеи до воплощения. Если пойдете по второму пути, то все равно нужно реализовать в коде предложенную фичу, чтобы наши автотесты проверили ваш код.

В требованиях к заданию есть творческая составляющая — нужно будет написать отчет в формате md. Если идете путем своей фичи - описываете в этой части свою фичу, если нет — то нашу. Подробности ниже.

### Давайте сначала присмотримся к фиче, предложенной нами

Кто-то проанализировал рынок за вас и решил, что киллер-фичей, которую так необходимо реализовать во что бы то ни стало, является "VIP ссылки"!

Что это? Всё просто. Вы помните, что `UrlShortener` возвращает произвольную комбинацию символов в укороченном URL. А в VIP ссылках, это не так: пользователь сам указывает, какой будет его короткая ссылка, конечно, только если заданная им комбинация символов свободна.

Формальное описание интерфейса на OpenAPI 3.0 тут [openapi.yaml](openapi.yaml)

А ниже для общего представления неформальное описание.

make_shorter на входе получает:
```
url = "user-defined-long-url"
optional vip_key = "user-defined-symbols"
optional time_to_live = 1
optional time_to_live_unit = SECONDS, MINUTES, HOURS, DAYS
```

Максимальный TimeToLive не должен превышать 2 дней (иначе красивые vip ссылки закончатся).

В ответ на операцию приходит
```
short_url = "example.com/xyz" - короткая ссылка
secret_key - ключ для управления ссылкой
```

Ну или ошибка 400, если есть какие-то проблемы с входными параметрами, например, если vip_key уже занят или переданы невалидные значения для TTL.

### Требования к результату домашней работы

Тебе выдан форк репозитория сервиса UrlShortener.
Изменения в коде нужно сделать через Merge Request в свой репозиторий. Таким образом для разработки отводится новая ветка от master, и по ней создается Merge Request.
Для этого задания предусмотрена автоматическая проверка в LMS, которая запускает тесты из ветки мастер и вычисляет количество заработанных баллов.
На примере одного из студенческих решений на разборе проверим как можно было реализовать задание. Провалидируем получившиеся продуктовые гипотезы, рассмотрим реализацию фичи в коде, дизайн AB-эксперимента, продуктовые метрики.
В идеале мы хотим, чтобы студент проделал следующую работу:

1. Описал идею в 1-2 предложениях
2. Сформулировал продуктовые гипотезы: 1-2 штуки в формате если <действие> то <следствие> потому что <объяснение>

3. Оценил примерные трудозатраты на полноценную реализацию в бэкенде (попробуй аргументировать оценку, например, требуемым количеством новых классов, объемом кода)
4. Придумал, можно ли сделать MVP, если да, то как оно будет выглядеть и сколько это займет времени
5. Проработал архитектуру и описал ее в тексте (в качестве формального описания подойдут диаграммы классов, компонентные диаграммы, диаграммы последовательности UML - в зависимости от того, что лучше отразит суть изменений и, что по вашему мнению будет понятнее проверяющему)
6. Реализовал полное решение идеи в коде. Это та часть работы, которая будет проверена автотестированием.
7. Добиться, чтобы все предоставленные в исходном репозитории тесты на vip-ссылки проходили успешно, внося правки в код сервиса, а не тестов :)
9. Придумал АБ-тест: какие выборки пользователей будут в эксперименте? Какие параметры фичи будем проверять в каждой выборке?
10. Выбрал и описал набор наблюдаемых продуктовых метрик, по которым можно сделать вывод, что идея "взлетела". Какие значения метрик ожидаем увидеть?
11. Сделал отчет в файле design.md в своем репозитории с ответами на эти вопросы.


### А что, если у меня своя классная продуктовая идея?

Если есть своя идея, как вырастить счастье пользователей UrlShortener, то можно реализовать и её (дополнительно).

Это необязательное задание, но оно будет оценено дополнительными баллами для тех, кто презентовал свою идею на встрече по разбору домашнего задания.

Что нужно сделать:

* Собственную идею необходимо разрабатывать в отдельной ветке в своем форке репозитория
* Описать путь твоей фичи от идеи до оценки эффекта ее внедрения по алгоритму, описанному в требованиях к работе: продуктовые гипотезы, план и оценка трудозатрат, MVP, архитектура, реализация (тестирование можно опустить), АБ-тесты, метрики.
* Записать короткий (до 2 минут) видео ролик с презентацией своей идеи.
* Презентовать свою идею на встрече по разбору домашнего задания.

Если что-то непонятно, смело задавай вопросы своему ментору.

## Работа с приложением

### Требования

Необходимо, чтобы были установлены следующие компоненты:

- `Docker` и `docker-compose`
- `Python 3.12`
- `Poetry`

### Установка

1. Создание виртуального окружения и установка зависимостей
```commandline
poetry install
```

2. Активация виртуального окружения

```commandline
poetry shell
```


### Запуск

0. Создать `.env` файл с этими переменными (можно командой `make env`)
```dotenv
POSTGRES_DB=...
POSTGRES_USER=...
POSTGRES_PASSWORD=...
POSTGRES_HOST=...
POSTGRES_PORT=5432
```

2. Создание базы в docker-контейнере (чтобы не работать с локальной базой):
```commandline
make db
```
2. Выполнение миграций:
```commandline
make migrate head
```
3. Запуск приложения:
```commandline
make run
```

Посмотреть документацию можно после запуска приложения по адресу `http://127.0.0.1:8080/swagger`.
### Тестирование

- Запуск тестов со всеми необходимыми флагами:
```commandline
make test
```

- Запуск тестов с генерацией отчета о покрытии:
```commandline
make test-cov
```

### Статический анализ

- Запуск линтеров
```commandline
make lint
```

- Запуск форматирования кода
```commandline
make format
```

### Дополнительные команды

- Создание новой ревизии:
```commandline
make revision
```
- Открытие базы данных внутри Docker-контейнера:
```commandline
make open_db
```

- Вывести список всех команд и их описание:
```commandline
make help
```

## Проверка

- При автоматической проверке будут запускаться линтер и тесты (make lint && make test). Поэтому перед отправкой убедитесь, что ваше решение проходит их локально.
